import{I as zr}from"./I77YJK47.js";import{b as Yn}from"./OIXXMIO2.js";import{a as Fr}from"./SZ3C6HJE.js";import{f as Zn}from"./UTGLRY7A.js";var H=Zn(Fr()),yo=Zn(zr());function Wr(e){let t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Gr=Wr,I=Gr;function Kr(e){return!!e&&typeof e.then=="function"}var K=Kr;function Hr(e,t){if(e!=null)return e;throw I(t??"Got unexpected null or undefined")}var Y=Hr;function U(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var Fe=class{getValue(){throw I("BaseLoadable")}toPromise(){throw I("BaseLoadable")}valueMaybe(){throw I("BaseLoadable")}valueOrThrow(){throw I(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw I("BaseLoadable")}promiseOrThrow(){throw I(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw I("BaseLoadable")}errorOrThrow(){throw I(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw I("BaseLoadable")}},fn=class extends Fe{constructor(t){super(),U(this,"state","hasValue"),U(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{let n=t(this.contents);return K(n)?Ve(n):ze(n)?n:ut(n)}catch(n){return K(n)?Ve(n.next(()=>this.map(t))):kt(n)}}},hn=class extends Fe{constructor(t){super(),U(this,"state","hasError"),U(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}},Et=class extends Fe{constructor(t){super(),U(this,"state","loading"),U(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ve(this.contents.then(n=>{let o=t(n);if(ze(o)){let r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(K(n))return n.then(()=>this.map(t).contents);throw n}))}};function ut(e){return Object.freeze(new fn(e))}function kt(e){return Object.freeze(new hn(e))}function Ve(e){return Object.freeze(new Et(e))}function go(){return Object.freeze(new Et(new Promise(()=>{})))}function qr(e){return e.every(t=>t.state==="hasValue")?ut(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?kt(Y(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ve(Promise.all(e.map(t=>t.contents)))}function bo(e){let n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>ze(r)?r:K(r)?Ve(r):ut(r)),o=qr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,i,l)=>({...a,[i]:r[l]}),{}))}function ze(e){return e instanceof Fe}var jr={of:e=>K(e)?Ve(e):ze(e)?e:ut(e),error:e=>kt(e),loading:()=>go(),all:bo,isLoadable:ze},$e={loadableWithValue:ut,loadableWithError:kt,loadableWithPromise:Ve,loadableLoading:go,loadableAll:bo,isLoadable:ze,RecoilLoadable:jr},Zr=$e.loadableWithValue,Yr=$e.loadableWithError,Xr=$e.loadableWithPromise,Jr=$e.loadableLoading,Qr=$e.loadableAll,ea=$e.isLoadable,ta=$e.RecoilLoadable,dt=Object.freeze({__proto__:null,loadableWithValue:Zr,loadableWithError:Yr,loadableWithPromise:Xr,loadableLoading:Jr,loadableAll:Qr,isLoadable:ea,RecoilLoadable:ta}),_n={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function na(e,t){var n,o;let r=(n=process.env[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw I(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function oa(e,t){var n;let o=(n=process.env[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function ra(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(na("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{_n.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),oa("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{_n.RECOIL_GKS_ENABLED.add(n)})}))}ra();var qe=_n;function Bt(e){return qe.RECOIL_GKS_ENABLED.has(e)}Bt.setPass=e=>{qe.RECOIL_GKS_ENABLED.add(e)};Bt.setFail=e=>{qe.RECOIL_GKS_ENABLED.delete(e)};Bt.clear=()=>{qe.RECOIL_GKS_ENABLED.clear()};var G=Bt;function aa(e,t,{error:n}={}){return null}var ia=aa,se=ia,on,rn,an,sa=(on=H.default.createMutableSource)!==null&&on!==void 0?on:H.default.unstable_createMutableSource,To=(rn=H.default.useMutableSource)!==null&&rn!==void 0?rn:H.default.unstable_useMutableSource,Ln=(an=H.default.useSyncExternalStore)!==null&&an!==void 0?an:H.default.unstable_useSyncExternalStore,Xn=!1;function ca(){var e;let{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=H.default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,r=((e=t?.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null;return Ln&&!r&&!Xn&&(Xn=!0,se("A React renderer without React 18+ API support is being used with React 18+.")),r}function la(){return G("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:G("recoil_sync_external_store")&&Ln!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:G("recoil_mutable_source")&&To!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?G("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:G("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function ua(){return!1}var je={createMutableSource:sa,useMutableSource:To,useSyncExternalStore:Ln,currentRendererSupportsUseSyncExternalStore:ca,reactMode:la,isFastRefreshEnabled:ua},st=class{constructor(t){U(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}},Nt=class extends st{},wt=class extends st{};function da(e){return e instanceof Nt||e instanceof wt}var Pt={AbstractRecoilValue:st,RecoilState:Nt,RecoilValueReadOnly:wt,isRecoilValue:da},fa=Pt.AbstractRecoilValue,ha=Pt.RecoilState,_a=Pt.RecoilValueReadOnly,pa=Pt.isRecoilValue,Le=Object.freeze({__proto__:null,AbstractRecoilValue:fa,RecoilState:ha,RecoilValueReadOnly:_a,isRecoilValue:pa});function va(e,...t){}var Ra=va,Cn=Ra;function Sa(e,t){return function*(){let n=0;for(let o of e)yield t(o,n++)}()}var xt=Sa,{isFastRefreshEnabled:wd}=je,At=class{},ma=new At,Ce=new Map,$n=new Map;function ya(e){return xt(e,t=>Y($n.get(t)))}function ga(e){if(Ce.has(e)){let t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`}}function ba(e){qe.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&ga(e.key),Ce.set(e.key,e);let t=e.set==null?new Le.RecoilValueReadOnly(e.key):new Le.RecoilState(e.key);return $n.set(e.key,t),t}var Vt=class extends Error{};function Ta(e){let t=Ce.get(e);if(t==null)throw new Vt(`Missing definition for RecoilValue: "${e}""`);return t}function Ea(e){return Ce.get(e)}var Lt=new Map;function Na(e){var t;if(!G("recoil_memory_managament_2020"))return;let n=Ce.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ce.delete(e),(o=Eo(e))===null||o===void 0||o(),Lt.delete(e)}}function wa(e,t){G("recoil_memory_managament_2020")&&(t===void 0?Lt.delete(e):Lt.set(e,t))}function Eo(e){return Lt.get(e)}var de={nodes:Ce,recoilValues:$n,registerNode:ba,getNode:Ta,getNodeMaybe:Ea,deleteNodeConfigIfPossible:Na,setConfigDeletionHandler:wa,getConfigDeletionHandler:Eo,recoilValuesForKeys:ya,NodeMissingError:Vt,DefaultValue:At,DEFAULT_VALUE:ma};function Aa(e,t){t()}var Va={enqueueExecution:Aa};function La(e,t){return t={exports:{}},e(t,t.exports),t.exports}var Ca=La(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,i=r/2,l=r/4,u={},f=function(s){return function(){return s}},_=n.hash=function(c){var s=typeof c>"u"?"undefined":t(c);if(s==="number")return c;s!=="string"&&(c+="");for(var h=0,S=0,m=c.length;S<m;++S){var g=c.charCodeAt(S);h=(h<<5)-h+g|0}return h},v=function(s){return s-=s>>1&1431655765,s=(s&858993459)+(s>>2&858993459),s=s+(s>>4)&252645135,s+=s>>8,s+=s>>16,s&127},C=function(s,h){return h>>>s&a},L=function(s){return 1<<s},y=function(s,h){return v(s&h-1)},N=function(s,h,S,m){var g=m;if(!s){var V=m.length;g=new Array(V);for(var w=0;w<V;++w)g[w]=m[w]}return g[h]=S,g},X=function(s,h,S){var m=S.length-1,g=0,V=0,w=S;if(s)g=V=h;else for(w=new Array(m);g<h;)w[V++]=S[g++];for(++g;g<=m;)w[V++]=S[g++];return s&&(w.length=m),w},ne=function(s,h,S,m){var g=m.length;if(s){for(var V=g;V>=h;)m[V--]=m[V];return m[h]=S,m}for(var w=0,A=0,D=new Array(g+1);w<h;)D[A++]=m[w++];for(D[h]=S;w<g;)D[++A]=m[w++];return D},E=1,B=2,J=3,z=4,q={__hamt_isEmpty:!0},Q=function(s){return s===q||s&&s.__hamt_isEmpty},ce=function(s,h,S,m){return{type:E,edit:s,hash:h,key:S,value:m,_modify:Me}},ye=function(s,h,S){return{type:B,edit:s,hash:h,children:S,_modify:Oe}},F=function(s,h,S){return{type:J,edit:s,mask:h,children:S,_modify:P}},ae=function(s,h,S){return{type:z,edit:s,size:h,children:S,_modify:x}},we=function(s){return s===q||s.type===E||s.type===B},re=function(s,h,S,m,g){for(var V=[],w=m,A=0,D=0;w;++D)w&1&&(V[D]=g[A++]),w>>>=1;return V[h]=S,ae(s,A+1,V)},fe=function(s,h,S,m){for(var g=new Array(h-1),V=0,w=0,A=0,D=m.length;A<D;++A)if(A!==S){var Z=m[A];Z&&!Q(Z)&&(g[V++]=Z,w|=1<<A)}return F(s,w,g)},Ie=function c(s,h,S,m,g,V){if(S===g)return ye(s,S,[V,m]);var w=C(h,S),A=C(h,g);return F(s,L(w)|L(A),w===A?[c(s,h+o,S,m,g,V)]:w<A?[m,V]:[V,m])},De=function(s,h,S,m,g,V,w,A){for(var D=g.length,Z=0;Z<D;++Z){var le=g[Z];if(S(w,le.key)){var oe=le.value,pe=V(oe);return pe===oe?g:pe===u?(--A.value,X(s,Z,g)):N(s,Z,ce(h,m,w,pe),g)}}var ve=V();return ve===u?g:(++A.value,N(s,D,ce(h,m,w,ve),g))},ge=function(s,h){return s===h.edit},Me=function(s,h,S,m,g,V,w){if(h(V,this.key)){var A=m(this.value);return A===this.value?this:A===u?(--w.value,q):ge(s,this)?(this.value=A,this):ce(s,g,V,A)}var D=m();return D===u?this:(++w.value,Ie(s,S,this.hash,this,g,ce(s,g,V,D)))},Oe=function(s,h,S,m,g,V,w){if(g===this.hash){var A=ge(s,this),D=De(A,s,h,this.hash,this.children,m,V,w);return D===this.children?this:D.length>1?ye(s,this.hash,D):D[0]}var Z=m();return Z===u?this:(++w.value,Ie(s,S,this.hash,this,g,ce(s,g,V,Z)))},P=function(s,h,S,m,g,V,w){var A=this.mask,D=this.children,Z=C(S,g),le=L(Z),oe=y(A,le),pe=A&le,ve=pe?D[oe]:q,Be=ve._modify(s,h,S+o,m,g,V,w);if(ve===Be)return this;var Rt=ge(s,this),Ye=A,Xe=void 0;if(pe&&Q(Be)){if(Ye&=~le,!Ye)return q;if(D.length<=2&&we(D[oe^1]))return D[oe^1];Xe=X(Rt,oe,D)}else if(!pe&&!Q(Be)){if(D.length>=i)return re(s,Z,Be,A,D);Ye|=le,Xe=ne(Rt,oe,Be,D)}else Xe=N(Rt,oe,Be,D);return Rt?(this.mask=Ye,this.children=Xe,this):F(s,Ye,Xe)},x=function(s,h,S,m,g,V,w){var A=this.size,D=this.children,Z=C(S,g),le=D[Z],oe=(le||q)._modify(s,h,S+o,m,g,V,w);if(le===oe)return this;var pe=ge(s,this),ve=void 0;if(Q(le)&&!Q(oe))++A,ve=N(pe,Z,oe,D);else if(!Q(le)&&Q(oe)){if(--A,A<=l)return fe(s,A,Z,D);ve=N(pe,Z,q,D)}else ve=N(pe,Z,oe,D);return pe?(this.size=A,this.children=ve,this):ae(s,A,ve)};q._modify=function(c,s,h,S,m,g,V){var w=S();return w===u?q:(++V.value,ce(c,m,g,w))};function d(c,s,h,S,m){this._editable=c,this._edit=s,this._config=h,this._root=S,this._size=m}d.prototype.setTree=function(c,s){return this._editable?(this._root=c,this._size=s,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,s)};var p=n.tryGetHash=function(c,s,h,S){for(var m=S._root,g=0,V=S._config.keyEq;;)switch(m.type){case E:return V(h,m.key)?m.value:c;case B:{if(s===m.hash)for(var w=m.children,A=0,D=w.length;A<D;++A){var Z=w[A];if(V(h,Z.key))return Z.value}return c}case J:{var le=C(g,s),oe=L(le);if(m.mask&oe){m=m.children[y(m.mask,oe)],g+=o;break}return c}case z:{if(m=m.children[C(g,s)],m){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,s,h){return p(c,s,h,this)};var R=n.tryGet=function(c,s,h){return p(c,h._config.hash(s),s,h)};d.prototype.tryGet=function(c,s){return R(c,s,this)};var $=n.getHash=function(c,s,h){return p(void 0,c,s,h)};d.prototype.getHash=function(c,s){return $(c,s,this)};var b=n.get=function(c,s){return p(void 0,s._config.hash(c),c,s)};d.prototype.get=function(c,s){return R(s,c,this)};var O=n.has=function(c,s,h){return p(u,c,s,h)!==u};d.prototype.hasHash=function(c,s){return O(c,s,this)};var k=n.has=function(c,s){return O(s._config.hash(c),c,s)};d.prototype.has=function(c){return k(c,this)};var T=function(s,h){return s===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||T,hash:c&&c.hash||_},q,0)},n.empty=n.make();var te=n.isEmpty=function(c){return c&&!!Q(c._root)};d.prototype.isEmpty=function(){return te(this)};var ee=n.modifyHash=function(c,s,h,S){var m={value:S._size},g=S._root._modify(S._editable?S._edit:NaN,S._config.keyEq,0,c,s,h,m);return S.setTree(g,m.value)};d.prototype.modifyHash=function(c,s,h){return ee(h,c,s,this)};var W=n.modify=function(c,s,h){return ee(c,h._config.hash(s),s,h)};d.prototype.modify=function(c,s){return W(s,c,this)};var j=n.setHash=function(c,s,h,S){return ee(f(h),c,s,S)};d.prototype.setHash=function(c,s,h){return j(c,s,h,this)};var he=n.set=function(c,s,h){return j(h._config.hash(c),c,s,h)};d.prototype.set=function(c,s){return he(c,s,this)};var ke=f(u),ie=n.removeHash=function(c,s,h){return ee(ke,c,s,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,s){return ie(c,s,this)};var _e=n.remove=function(c,s){return ie(s._config.hash(c),c,s)};d.prototype.remove=d.prototype.delete=function(c){return _e(c,this)};var Gn=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return Gn(this)};var Kn=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return Kn(this)};var $r=n.mutate=function(c,s){var h=Gn(s);return c(h),Kn(h)};d.prototype.mutate=function(c){return $r(c,this)};var en=function(s){return s&&Hn(s[0],s[1],s[2],s[3],s[4])},Hn=function(s,h,S,m,g){for(;S<s;){var V=h[S++];if(V&&!Q(V))return qn(V,m,[s,h,S,m,g])}return en(g)},qn=function(s,h,S){switch(s.type){case E:return{value:h(s),rest:S};case B:case z:case J:var m=s.children;return Hn(m.length,m,0,h,S);default:return en(S)}},Ur={done:!0};function tn(c){this.v=c}tn.prototype.next=function(){if(!this.v)return Ur;var c=this.v;return this.v=en(c.rest),c},tn.prototype[Symbol.iterator]=function(){return this};var nn=function(s,h){return new tn(qn(s._root,h))},Ir=function(s){return[s.key,s.value]},Dr=n.entries=function(c){return nn(c,Ir)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return Dr(this)};var Mr=function(s){return s.key},Or=n.keys=function(c){return nn(c,Mr)};d.prototype.keys=function(){return Or(this)};var kr=function(s){return s.value},Br=n.values=d.prototype.values=function(c){return nn(c,kr)};d.prototype.values=function(){return Br(this)};var jn=n.fold=function(c,s,h){var S=h._root;if(S.type===E)return c(s,S.value,S.key);for(var m=[S.children],g=void 0;g=m.pop();)for(var V=0,w=g.length;V<w;){var A=g[V++];A&&A.type&&(A.type===E?s=c(s,A.value,A.key):m.push(A.children))}return s};d.prototype.fold=function(c,s){return jn(c,s,this)};var Pr=n.forEach=function(c,s){return jn(function(h,S,m){return c(S,m,s)},null,s)};d.prototype.forEach=function(c){return Pr(c,this)};var xr=n.count=function(c){return c._size};d.prototype.count=function(){return xr(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}),pn=class{constructor(t){U(this,"_map",void 0),this._map=new Map(t?.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return Un(this)}toMap(){return new Map(this._map)}},ct=class{constructor(t){if(U(this,"_hamt",Ca.empty.beginMutation()),t instanceof ct){let n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(let[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return Un(this)}toMap(){return new Map(this._hamt)}};function Un(e){return G("recoil_hamt_2020")?new ct(e):new pn(e)}var $a={persistentMap:Un},Ua=$a.persistentMap,Ia=Object.freeze({__proto__:null,persistentMap:Ua});function Da(e,...t){let n=new Set;e:for(let o of e){for(let r of t)if(r.has(o))continue e;n.add(o)}return n}var rt=Da;function Ma(e,t){let n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var Ct=Ma;function Oa(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function ka(e){return{nodeDeps:Ct(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:Ct(e.nodeToNodeSubscriptions,t=>new Set(t))}}function sn(e,t,n,o){let{nodeDeps:r,nodeToNodeSubscriptions:a}=n,i=r.get(e);if(i&&o&&i!==o.nodeDeps.get(e))return;r.set(e,t);let l=i==null?t:rt(t,i);for(let u of l)a.has(u)||a.set(u,new Set),Y(a.get(u)).add(e);if(i){let u=rt(i,t);for(let f of u){if(!a.has(f))return;let _=Y(a.get(f));_.delete(e),_.size===0&&a.delete(f)}}}function Ba(e,t,n,o){var r,a,i,l;let u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||o===((a=u.previousTree)===null||a===void 0?void 0:a.version)||se("Tried to save dependencies to a discarded tree");let f=n.getGraph(o);if(sn(e,t,f),o===((i=u.previousTree)===null||i===void 0?void 0:i.version)){let v=n.getGraph(u.currentTree.version);sn(e,t,v,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var _;let v=(_=u.nextTree)===null||_===void 0?void 0:_.version;if(v!==void 0){let C=n.getGraph(v);sn(e,t,C,f)}}}var ft={cloneGraph:ka,graph:Oa,saveDepsToStore:Ba},Pa=0,xa=()=>Pa++,Fa=0,za=()=>Fa++,Wa=0,Ga=()=>Wa++,Ft={getNextTreeStateVersion:xa,getNextStoreID:za,getNextComponentID:Ga},{persistentMap:Jn}=Ia,{graph:Ka}=ft,{getNextTreeStateVersion:No}=Ft;function wo(){let e=No();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Jn(),nonvalidatedAtoms:Jn()}}function Ha(){let e=wo();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Ka()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var Ao={makeEmptyTreeState:wo,makeEmptyStoreState:Ha,getNextTreeStateVersion:No},$t=class{};function qa(){return new $t}var zt={RetentionZone:$t,retentionZone:qa};function ja(e,t){let n=new Set(e);return n.add(t),n}function Za(e,t){let n=new Set(e);return n.delete(t),n}function Ya(e,t,n){let o=new Map(e);return o.set(t,n),o}function Xa(e,t,n){let o=new Map(e);return o.set(t,n(o.get(t))),o}function Ja(e,t){let n=new Map(e);return n.delete(t),n}function Qa(e,t){let n=new Map(e);return t.forEach(o=>n.delete(o)),n}var Vo={setByAddingToSet:ja,setByDeletingFromSet:Za,mapBySettingInMap:Ya,mapByUpdatingInMap:Xa,mapByDeletingFromMap:Ja,mapByDeletingMultipleFromMap:Qa};function*ei(e,t){let n=0;for(let o of e)t(o,n++)&&(yield o)}var In=ei;function ti(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var Lo=ti,{getNode:ht,getNodeMaybe:ni,recoilValuesForKeys:Qn}=de,{RetentionZone:eo}=zt,{setByAddingToSet:oi}=Vo,ri=Object.freeze(new Set),vn=class extends Error{};function ai(e,t,n){if(!G("recoil_memory_managament_2020"))return()=>{};let{nodesRetainedByZone:o}=e.getState().retention;function r(a){let i=o.get(a);i||o.set(a,i=new Set),i.add(t)}if(n instanceof eo)r(n);else if(Array.isArray(n))for(let a of n)r(a);return()=>{if(!G("recoil_memory_managament_2020"))return;let{retention:a}=e.getState();function i(l){let u=a.nodesRetainedByZone.get(l);u?.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof eo)i(n);else if(Array.isArray(n))for(let l of n)i(l)}}function Dn(e,t,n,o){let r=e.getState();if(r.nodeCleanupFunctions.has(n))return;let a=ht(n),i=ai(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),i()})}function ii(e,t,n){Dn(e,e.getState().currentTree,t,n)}function si(e,t){var n;let o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function ci(e,t,n){return Dn(e,t,n,"get"),ht(n).get(e,t)}function Co(e,t,n){return ht(n).peek(e,t)}function li(e,t,n){var o;let r=ni(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:oi(e.dirtyAtoms,t)}}function ui(e,t,n,o){let r=ht(n);if(r.set==null)throw new vn(`Attempt to set read-only RecoilValue: ${n}`);let a=r.set;return Dn(e,t,n,"set"),a(e,t,o)}function di(e,t,n){let o=e.getState(),r=e.getGraph(t.version),a=ht(n).nodeType;return Lo({type:a},{loadable:()=>Co(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var i;return Qn((i=r.nodeDeps.get(n))!==null&&i!==void 0?i:[])},subscribers:()=>{var i,l;return{nodes:Qn(In($o(e,t,new Set([n])),u=>u!==n)),components:xt((i=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&i!==void 0?i:[],([u])=>({name:u}))}}})}function $o(e,t,n){let o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var i;o.add(l);let u=(i=a.nodeToNodeSubscriptions.get(l))!==null&&i!==void 0?i:ri;for(let f of u)o.has(f)||r.push(f)}return o}var Ee={getNodeLoadable:ci,peekNodeLoadable:Co,setNodeValue:ui,initializeNode:ii,cleanUpNode:si,setUnvalidatedAtomValue_DEPRECATED:li,peekNodeInfo:di,getDownstreamNodes:$o},Uo=null;function fi(e){Uo=e}function hi(){var e;(e=Uo)===null||e===void 0||e()}var Io={setInvalidateMemoizedSnapshot:fi,invalidateMemoizedSnapshot:hi},{getDownstreamNodes:_i,getNodeLoadable:Do,setNodeValue:pi}=Ee,{getNextComponentID:vi}=Ft,{getNode:Ri,getNodeMaybe:Mo}=de,{DefaultValue:Mn}=de,{reactMode:Si}=je,{AbstractRecoilValue:mi,RecoilState:yi,RecoilValueReadOnly:gi,isRecoilValue:bi}=Le,{invalidateMemoizedSnapshot:Ti}=Io;function Ei(e,{key:t},n=e.getState().currentTree){var o,r;let a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version)||se("Tried to read from a discarded tree");let i=Do(e,n,t);return i.state==="loading"&&i.contents.catch(()=>{}),i}function Ni(e,t){let n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof Mn?n.delete(r):n.set(r,o)}),n}function wi(e,t,{key:n},o){if(typeof o=="function"){let r=Do(e,t,n);if(r.state==="loading"){let a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw se(a),I(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function Ai(e,t,n){if(n.type==="set"){let{recoilValue:r,valueOrUpdater:a}=n,i=wi(e,t,r,a),l=pi(e,t,r.key,i);for(let[u,f]of l.entries())Rn(t,u,f)}else if(n.type==="setLoadable"){let{recoilValue:{key:r},loadable:a}=n;Rn(t,r,a)}else if(n.type==="markModified"){let{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;let{recoilValue:{key:r},unvalidatedValue:a}=n,i=Mo(r);i==null||(o=i.invalidate)===null||o===void 0||o.call(i,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else se(`Unknown action ${n.type}`)}function Rn(e,t,n){n.state==="hasValue"&&n.contents instanceof Mn?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function Oo(e,t){e.replaceState(n=>{let o=ko(n);for(let r of t)Ai(e,o,r);return Bo(e,o),Ti(),o})}function Wt(e,t){if(at.length){let n=at[at.length-1],o=n.get(e);o||n.set(e,o=[]),o.push(t)}else Oo(e,[t])}var at=[];function Vi(){let e=new Map;return at.push(e),()=>{for(let[n,o]of e)Oo(n,o);at.pop()!==e&&se("Incorrect order of batch popping")}}function ko(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function Bo(e,t){let n=_i(e,t,t.dirtyAtoms);for(let a of n){var o,r;(o=Mo(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function Po(e,t,n){Wt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function Li(e,t,n){if(n instanceof Mn)return Po(e,t,n);Wt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function Ci(e,t){Wt(e,{type:"markModified",recoilValue:t})}function $i(e,t,n){Wt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Ui(e,{key:t},n,o=null){let r=vi(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),Y(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);let i=Si();if(i.early&&(i.mode==="LEGACY"||i.mode==="MUTABLE_SOURCE")){let l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{let l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);if(u===void 0||!u.has(r)){se(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`);return}u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t)}}}function Ii(e,t){var n;let{currentTree:o}=e.getState(),r=Ri(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var Se={RecoilValueReadOnly:gi,AbstractRecoilValue:mi,RecoilState:yi,getRecoilValueAsLoadable:Ei,setRecoilValue:Po,setRecoilValueLoadable:Li,markRecoilValueModified:Ci,setUnvalidatedRecoilValue:$i,subscribeToRecoilValue:Ui,isRecoilValue:bi,applyAtomValueWrites:Ni,batchStart:Vi,writeLoadableToTreeState:Rn,invalidateDownstreams:Bo,copyTreeState:ko,refreshRecoilValue:Ii};function Di(e,t,n){let o=e.entries(),r=o.next();for(;!r.done;){let a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Mi=Di,{cleanUpNode:Oi}=Ee,{deleteNodeConfigIfPossible:ki,getNode:xo}=de,{RetentionZone:Fo}=zt,Bi=12e4,zo=new Set;function Wo(e,t){let n=e.getState(),o=n.currentTree;if(n.nextTree){se("releaseNodesNowOnCurrentTree should only be called at the end of a batch");return}let r=new Set;for(let i of t)if(i instanceof Fo)for(let l of zi(n,i))r.add(l);else r.add(i);let a=Pi(e,r);for(let i of a)Fi(e,o,i)}function Pi(e,t){let n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return l(t),a;function l(u){let f=new Set,_=xi(e,o,u,a,i);for(let y of _){var v;if(xo(y).retainedBy==="recoilRoot"){i.add(y);continue}if(((v=n.retention.referenceCounts.get(y))!==null&&v!==void 0?v:0)>0){i.add(y);continue}if(Go(y).some(X=>n.retention.referenceCounts.get(X))){i.add(y);continue}let N=r.nodeToNodeSubscriptions.get(y);if(N&&Mi(N,X=>i.has(X))){i.add(y);continue}a.add(y),f.add(y)}let C=new Set;for(let y of f)for(let N of(L=r.nodeDeps.get(y))!==null&&L!==void 0?L:zo){var L;a.has(N)||C.add(N)}C.size&&l(C)}}function xi(e,t,n,o,r){let a=e.getGraph(t.version),i=[],l=new Set;for(;n.size>0;)u(Y(n.values().next().value));return i;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;let _=a.nodeToNodeSubscriptions.get(f);if(_)for(let v of _)u(v);l.add(f),n.delete(f),i.push(f)}}function Fi(e,t,n){if(!G("recoil_memory_managament_2020"))return;Oi(e,n);let o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);let r=Go(n);for(let u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);let i=o.graphsByVersion.get(t.version);if(i){let u=i.nodeDeps.get(n);if(u!==void 0){i.nodeDeps.delete(n);for(let f of u){var l;(l=i.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}ki(n)}function zi(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:zo}function Go(e){let t=xo(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof Fo?[t]:t}function Wi(e,t){let n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):Wo(e,new Set([t]))}function Gi(e,t,n){var o;if(!G("recoil_memory_managament_2020"))return;let r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Ko(e,t):r.set(t,a)}function Ko(e,t){if(!G("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Wi(e,t)}function Ki(e){if(!G("recoil_memory_managament_2020"))return;let t=e.getState();Wo(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Hi(e){return e===void 0?"recoilRoot":e}var Ue={SUSPENSE_TIMEOUT_MS:Bi,updateRetainCount:Gi,updateRetainCountToZero:Ko,releaseScheduledRetainablesNow:Ki,retainedByOptionWithDefault:Hi},{unstable_batchedUpdates:qi}=yo.default,ji={unstable_batchedUpdates:qi},{unstable_batchedUpdates:Zi}=ji,Yi={unstable_batchedUpdates:Zi},{batchStart:Xi}=Se,{unstable_batchedUpdates:Ji}=Yi,On=Ji||(e=>e()),Qi=e=>{On=e},es=()=>On,ts=e=>{On(()=>{let t=()=>{};try{t=Xi(),e()}finally{t()}})},Gt={getBatcher:es,setBatcher:Qi,batchUpdates:ts};function*ns(e){for(let t of e)for(let n of t)yield n}var Ho=ns,qo=typeof Window>"u"||typeof window>"u",os=e=>!qo&&(e===window||e instanceof Window),rs=typeof navigator<"u"&&navigator.product==="ReactNative",_t={isSSR:qo,isReactNative:rs,isWindow:os};function as(e,t){let n;return(...o)=>{n||(n={});let r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function is(e,t){let n,o;return(...r)=>{let a=t(...r);return n===a||(n=a,o=e(...r)),o}}function ss(e,t){let n,o;return[(...i)=>{let l=t(...i);return n===l||(n=l,o=e(...i)),o},()=>{n=null}]}var cs={memoizeWithArgsHash:as,memoizeOneWithArgsHash:is,memoizeOneWithArgsHashAndInvalidation:ss},{batchUpdates:Sn}=Gt,{initializeNode:ls,peekNodeInfo:us}=Ee,{graph:ds}=ft,{getNextStoreID:fs}=Ft,{DEFAULT_VALUE:hs,recoilValues:to,recoilValuesForKeys:no}=de,{AbstractRecoilValue:_s,getRecoilValueAsLoadable:ps,setRecoilValue:oo,setUnvalidatedRecoilValue:vs}=Se,{updateRetainCount:Tt}=Ue,{setInvalidateMemoizedSnapshot:Rs}=Io,{getNextTreeStateVersion:Ss,makeEmptyStoreState:ms}=Ao,{isSSR:ys}=_t,{memoizeOneWithArgsHashAndInvalidation:gs}=cs;var We=class{constructor(t,n){U(this,"_store",void 0),U(this,"_refCount",1),U(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),ps(this._store,o))),U(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),U(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),o?.isModified===!0){if(o?.isInitialized===!1)return[];let i=this._store.getState().currentTree;return no(i.dirtyAtoms)}let r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return o?.isInitialized==null?to.values():o.isInitialized===!0?no(Ho([r,a])):In(to.values(),({key:i})=>!r.has(i)&&!a.has(i))}),U(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),us(this._store,this._store.getState().currentTree,o))),U(this,"map",o=>{this.checkRefCount_INTERNAL();let r=new lt(this,Sn);return o(r),r}),U(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();let r=new lt(this,Sn);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:fs(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{let r=t.graphsByVersion;if(r.has(o))return Y(r.get(o));let a=ds();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw I("Cannot subscribe to Snapshots")}};for(let o of this._store.getState().knownAtoms)ls(this._store,o,"get"),Tt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&se("Attempt to retain() Snapshot that was already released."),this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){ys||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!G("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){G("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}};function jo(e,t,n=!1){let o=e.getState(),r=n?Ss():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(xt(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function bs(e){let t=new We(ms());return e!=null?t.map(e):t}var[ro,Zo]=gs((e,t)=>{var n;let o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:Y(o.previousTree);return new We(jo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});Rs(Zo);function Ts(e,t="latest"){let n=ro(e,t);return n.isRetained()?n:(Zo(),ro(e,t))}var lt=class extends We{constructor(t,n){super(jo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),U(this,"_batch",void 0),U(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();let a=this.getStore_INTERNAL();this._batch(()=>{Tt(a,o.key,1),oo(this.getStore_INTERNAL(),o,r)})}),U(this,"reset",o=>{this.checkRefCount_INTERNAL();let r=this.getStore_INTERNAL();this._batch(()=>{Tt(r,o.key,1),oo(this.getStore_INTERNAL(),o,hs)})}),U(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();let r=this.getStore_INTERNAL();Sn(()=>{for(let[a,i]of o.entries())Tt(r,a,1),vs(r,new _s(a),i)})}),this._batch=n}},Kt={Snapshot:We,MutableSnapshot:lt,freshSnapshot:bs,cloneSnapshot:Ts},Es=Kt.Snapshot,Ns=Kt.MutableSnapshot,ws=Kt.freshSnapshot,As=Kt.cloneSnapshot,Ht=Object.freeze({__proto__:null,Snapshot:Es,MutableSnapshot:Ns,freshSnapshot:ws,cloneSnapshot:As});function Vs(...e){let t=new Set;for(let n of e)for(let o of n)t.add(o);return t}var Ls=Vs,{useRef:Cs}=H.default;function $s(e){let t=Cs(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var ao=$s,{getNextTreeStateVersion:Us,makeEmptyStoreState:Yo}=Ao,{cleanUpNode:Is,getDownstreamNodes:Ds,initializeNode:Ms,setNodeValue:Os,setUnvalidatedAtomValue_DEPRECATED:ks}=Ee,{graph:Bs}=ft,{cloneGraph:Ps}=ft,{getNextStoreID:Xo}=Ft,{createMutableSource:cn,reactMode:Jo}=je,{applyAtomValueWrites:xs}=Se,{releaseScheduledRetainablesNow:Qo}=Ue,{freshSnapshot:Fs}=Ht,{useCallback:zs,useContext:er,useEffect:mn,useMemo:Ws,useRef:Gs,useState:Ks}=H.default;function Je(){throw I("This component must be used inside a <RecoilRoot> component.")}var tr=Object.freeze({storeID:Xo(),getState:Je,replaceState:Je,getGraph:Je,subscribeToTransactions:Je,addTransactionMetadata:Je}),yn=!1;function io(e){if(yn)throw I("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");let t=e.getState();if(t.nextTree===null){G("recoil_memory_managament_2020")&&G("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Qo(e);let n=t.currentTree.version,o=Us();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Ps(Y(t.graphsByVersion.get(n))))}}var nr=H.default.createContext({current:tr}),qt=()=>er(nr),or=H.default.createContext(null);function Hs(){let e=er(or);return e==null&&Cn("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e}function kn(e,t,n){let o=Ds(e,n,n.dirtyAtoms);for(let r of o){let a=t.nodeToComponentSubscriptions.get(r);if(a)for(let[i,[l,u]]of a)u(n)}}function rr(e){let t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(let[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(let[i,l]of a)l(e);for(let[r,a]of t.transactionSubscriptions)a(e);(!Jo().early||t.suspendedComponentResolvers.size>0)&&(kn(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function qs(e){let t=e.getState();t.commitDepth++;try{let{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,rr(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):se("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,G("recoil_memory_managament_2020")&&n==null&&Qo(e)}finally{t.commitDepth--}}function js({setNotifyBatcherOfChange:e}){let t=qt(),[,n]=Ks([]);return e(()=>n({})),mn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),mn(()=>{Va.enqueueExecution("Batcher",()=>{qs(t.current)})}),null}function Zs(e,t){let n=Yo();return t({set:(o,r)=>{let a=n.currentTree,i=Os(e,a,o.key,r),l=new Set(i.keys()),u=a.nonvalidatedAtoms.clone();for(let f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:Ls(a.dirtyAtoms,l),atomValues:xs(a.atomValues,i),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=ks(n.currentTree,a,r)})}}),n}function Ys(e){let t=Fs(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}var so=0;function Xs({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r,a=L=>{let y=r.current.graphsByVersion;if(y.has(L))return Y(y.get(L));let N=Bs();return y.set(L,N),N},i=(L,y)=>{if(y==null){let{transactionSubscriptions:N}=v.current.getState(),X=so++;return N.set(X,L),{release:()=>{N.delete(X)}}}else{let{nodeTransactionSubscriptions:N}=v.current.getState();N.has(y)||N.set(y,new Map);let X=so++;return Y(N.get(y)).set(X,L),{release:()=>{let ne=N.get(y);ne&&(ne.delete(X),ne.size===0&&N.delete(y))}}}},l=L=>{io(v.current);for(let y of Object.keys(L))Y(v.current.getState().nextTree).transactionMetadata[y]=L[y]},u=L=>{io(v.current);let y=Y(r.current.nextTree),N;try{yn=!0,N=L(y)}finally{yn=!1}N!==y&&(r.current.nextTree=N,Jo().early&&kn(v.current,r.current,N),Y(f.current)())},f=Gs(null),_=zs(L=>{f.current=L},[f]),v=ao(()=>n??{storeID:Xo(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:i,addTransactionMetadata:l});n!=null&&(v.current=n),r=ao(()=>e!=null?Zs(v.current,e):t!=null?Ys(t):Yo());let C=Ws(()=>cn?.(r,()=>r.current.currentTree.version),[r]);return mn(()=>{let L=v.current;for(let y of new Set(L.getState().knownAtoms))Ms(L,y,"get");return()=>{for(let y of L.getState().knownAtoms)Is(L,y)}},[v]),H.default.createElement(nr.Provider,{value:v},H.default.createElement(or.Provider,{value:C},H.default.createElement(js,{setNotifyBatcherOfChange:_}),o))}function Js(e){let{override:t,...n}=e,o=qt();return t===!1&&o.current!==tr?e.children:H.default.createElement(Xs,n)}function Qs(){return qt().current.storeID}var be={RecoilRoot:Js,useStoreRef:qt,useRecoilMutableSource:Hs,useRecoilStoreID:Qs,notifyComponents_FOR_TESTING:kn,sendEndOfBatchNotifications_FOR_TESTING:rr};function ec(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var tc=ec,{useEffect:nc,useRef:oc}=H.default;function rc(e){let t=oc();return nc(()=>{t.current=e}),t.current}var ar=rc,{useStoreRef:ac}=be,{SUSPENSE_TIMEOUT_MS:ic}=Ue,{updateRetainCount:Qe}=Ue,{RetentionZone:sc}=zt,{useEffect:cc,useRef:lc}=H.default,{isSSR:co}=_t;function uc(e){if(G("recoil_memory_managament_2020"))return dc(e)}function dc(e){let n=(Array.isArray(e)?e:[e]).map(i=>i instanceof sc?i:i.key),o=ac();cc(()=>{if(!G("recoil_memory_managament_2020"))return;let i=o.current;if(r.current&&!co)window.clearTimeout(r.current),r.current=null;else for(let l of n)Qe(i,l,1);return()=>{for(let l of n)Qe(i,l,-1)}},[o,...n]);let r=lc(),a=ar(n);if(!co&&(a===void 0||!tc(a,n))){let i=o.current;for(let l of n)Qe(i,l,1);if(a)for(let l of a)Qe(i,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(let l of n)Qe(i,l,-1)},ic)}}var Bn=uc;function fc(){return"<component name not available>"}var pt=fc,{batchUpdates:hc}=Gt,{DEFAULT_VALUE:ir}=de,{currentRendererSupportsUseSyncExternalStore:_c,reactMode:Ze,useMutableSource:pc,useSyncExternalStore:vc}=je,{useRecoilMutableSource:Rc,useStoreRef:me}=be,{isRecoilValue:Ad}=Le,{AbstractRecoilValue:gn,getRecoilValueAsLoadable:vt,setRecoilValue:Ut,setUnvalidatedRecoilValue:Sc,subscribeToRecoilValue:Ge}=Se,{useCallback:ue,useEffect:Ke,useMemo:sr,useRef:it,useState:Pn}=H.default,{setByAddingToSet:mc}=Vo,{isSSR:yc}=_t;function xn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{let a=n.current.getState().suspendedComponentResolvers;a.add(r),yc&&K(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:I(`Invalid value of loadable atom "${t.key}"`)}function gc(){let e=pt(),t=me(),[,n]=Pn([]),o=it(new Set);o.current=new Set;let r=it(new Set),a=it(new Map),i=ue(u=>{let f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=ue((u,f)=>{a.current.has(f)&&n([])},[]);return Ke(()=>{let u=t.current;rt(o.current,r.current).forEach(f=>{if(a.current.has(f)){Cn(`Double subscription to RecoilValue "${f}"`);return}let _=Ge(u,new gn(f),C=>l(C,f),e);a.current.set(f,_),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),rt(r.current,o.current).forEach(f=>{i(f)}),r.current=o.current}),Ke(()=>{let u=a.current;return rt(o.current,new Set(u.keys())).forEach(f=>{let _=Ge(t.current,new gn(f),v=>l(v,f),e);u.set(f,_)}),()=>u.forEach((f,_)=>i(_))},[e,t,i,l]),sr(()=>{function u(y){return N=>{Ut(t.current,y,N)}}function f(y){return()=>Ut(t.current,y,ir)}function _(y){var N;o.current.has(y.key)||(o.current=mc(o.current,y.key));let X=t.current.getState();return vt(t.current,y,Ze().early&&(N=X.nextTree)!==null&&N!==void 0?N:X.currentTree)}function v(y){let N=_(y);return xn(N,y,t)}function C(y){return[v(y),u(y)]}function L(y){return[_(y),u(y)]}return{getRecoilValue:v,getRecoilValueLoadable:_,getRecoilState:C,getRecoilStateLoadable:L,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}var bc={current:0};function Tc(e){let t=me(),n=pt(),o=ue(()=>{var l;let u=t.current,f=u.getState(),_=Ze().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:vt(u,e,_),key:e.key}},[t,e]),r=ue(l=>{let u;return()=>{var f,_;let v=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(v.loadable)&&((_=u)===null||_===void 0?void 0:_.key)===v.key?u:(u=v,v)}},[]),a=sr(()=>r(o),[o,r]),i=ue(l=>{let u=t.current;return Ge(u,e,l,n).release},[t,e,n]);return vc(i,a,a).loadable}function Ec(e){let t=me(),n=ue(()=>{var f;let _=t.current,v=_.getState(),C=Ze().early&&(f=v.nextTree)!==null&&f!==void 0?f:v.currentTree;return vt(_,e,C)},[t,e]),o=ue(()=>n(),[n]),r=pt(),a=ue((f,_)=>{let v=t.current;return Ge(v,e,()=>{if(!G("recoil_suppress_rerender_in_callback"))return _();let L=n();u.current.is(L)||_(),u.current=L},r).release},[t,e,r,n]),i=Rc();if(i==null)throw I("Recoil hooks must be used in components contained within a <RecoilRoot> component.");let l=pc(i,o,a),u=it(l);return Ke(()=>{u.current=l}),l}function bn(e){let t=me(),n=pt(),o=ue(()=>{var u;let f=t.current,_=f.getState(),v=Ze().early&&(u=_.nextTree)!==null&&u!==void 0?u:_.currentTree;return vt(f,e,v)},[t,e]),r=ue(()=>({loadable:o(),key:e.key}),[o,e.key]),a=ue(u=>{let f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);Ke(()=>{let u=Ge(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);let[i,l]=Pn(r);return i.key!==e.key?r().loadable:i.loadable}function Nc(e){let t=me(),[,n]=Pn([]),o=pt(),r=ue(()=>{var l;let u=t.current,f=u.getState(),_=Ze().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return vt(u,e,_)},[t,e]),a=r(),i=it(a);return Ke(()=>{i.current=a}),Ke(()=>{let l=t.current,u=l.getState(),f=Ge(l,e,v=>{var C;if(!G("recoil_suppress_rerender_in_callback"))return n([]);let L=r();(C=i.current)!==null&&C!==void 0&&C.is(L)||n(L),i.current=L},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,n([])});else{var _;if(!G("recoil_suppress_rerender_in_callback"))return n([]);let v=r();(_=i.current)!==null&&_!==void 0&&_.is(v)||n(v),i.current=v}return f.release},[o,r,e,t]),a}function Fn(e){return G("recoil_memory_managament_2020")&&Bn(e),{TRANSITION_SUPPORT:bn,SYNC_EXTERNAL_STORE:_c()?Tc:bn,MUTABLE_SOURCE:Ec,LEGACY:Nc}[Ze().mode](e)}function cr(e){let t=me(),n=Fn(e);return xn(n,e,t)}function jt(e){let t=me();return ue(n=>{Ut(t.current,e,n)},[t,e])}function wc(e){let t=me();return ue(()=>{Ut(t.current,e,ir)},[t,e])}function Ac(e){return[cr(e),jt(e)]}function Vc(e){return[Fn(e),jt(e)]}function Lc(){let e=me();return(t,n={})=>{hc(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>Sc(e.current,new gn(r),o))})}}function lr(e){return G("recoil_memory_managament_2020")&&Bn(e),bn(e)}function ur(e){let t=me(),n=lr(e);return xn(n,e,t)}function Cc(e){return[ur(e),jt(e)]}var $c={recoilComponentGetRecoilValueCount_FOR_TESTING:bc,useRecoilInterface:gc,useRecoilState:Ac,useRecoilStateLoadable:Vc,useRecoilValue:cr,useRecoilValueLoadable:Fn,useResetRecoilState:wc,useSetRecoilState:jt,useSetUnvalidatedAtomValues:Lc,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:lr,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:ur,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Cc};function Uc(e,t){let n=new Map;for(let[o,r]of e)t(r,o)&&n.set(o,r);return n}var Ic=Uc;function Dc(e,t){let n=new Set;for(let o of e)t(o)&&n.add(o);return n}var Mc=Dc;function Oc(...e){let t=new Map;for(let n=0;n<e.length;n++){let o=e[n].keys(),r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var kc=Oc,{batchUpdates:Bc}=Gt,{DEFAULT_VALUE:Pc,getNode:dr,nodes:xc}=de,{useStoreRef:zn}=be,{AbstractRecoilValue:Fc,setRecoilValueLoadable:zc}=Se,{SUSPENSE_TIMEOUT_MS:Wc}=Ue,{cloneSnapshot:It}=Ht,{useCallback:Zt,useEffect:fr,useRef:lo,useState:Gc}=H.default,{isSSR:uo}=_t;function Yt(e){let t=zn();fr(()=>t.current.subscribeToTransactions(e).release,[e,t])}function fo(e){let t=e.atomValues.toMap(),n=Ct(Ic(t,(o,r)=>{let i=dr(r).persistence_UNSTABLE;return i!=null&&i.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return kc(e.nonvalidatedAtoms.toMap(),n)}function Kc(e){Yt(Zt(t=>{let n=t.getState().previousTree,o=t.getState().currentTree;n||(se("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);let r=fo(o),a=fo(n),i=Ct(xc,u=>{var f,_,v,C;return{persistence_UNSTABLE:{type:(f=(_=u.persistence_UNSTABLE)===null||_===void 0?void 0:_.type)!==null&&f!==void 0?f:"none",backButton:(v=(C=u.persistence_UNSTABLE)===null||C===void 0?void 0:C.backButton)!==null&&v!==void 0?v:!1}}}),l=Mc(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Hc(e){Yt(Zt(t=>{let n=It(t,"latest"),o=It(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function qc(){let e=zn(),[t,n]=Gc(()=>It(e.current)),o=ar(t),r=lo(),a=lo();if(Yt(Zt(l=>n(It(l)),[])),fr(()=>{let l=t.retain();if(r.current&&!uo){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!uo){if(r.current){var i;window.clearTimeout(r.current),r.current=null,(i=a.current)===null||i===void 0||i.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},Wc)}return t}function hr(e,t){var n;let o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Bc(()=>{let i=new Set;for(let f of[r.atomValues.keys(),a.atomValues.keys()])for(let _ of f){var l,u;((l=r.atomValues.get(_))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(_))===null||u===void 0?void 0:u.contents)&&dr(_).shouldRestoreFromSnapshots&&i.add(_)}i.forEach(f=>{zc(e,new Fc(f),a.atomValues.has(f)?Y(a.atomValues.get(f)):Pc)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function jc(){let e=zn();return Zt(t=>hr(e.current,t),[e])}var _r={useRecoilSnapshot:qc,gotoSnapshot:hr,useGotoRecoilSnapshot:jc,useRecoilTransactionObserver:Hc,useTransactionObservation_DEPRECATED:Kc,useTransactionSubscription_DEPRECATED:Yt},{peekNodeInfo:Zc}=Ee,{useStoreRef:Yc}=be;function Xc(){let e=Yc();return({key:t})=>Zc(e.current,e.current.getState().currentTree,t)}var Jc=Xc,{reactMode:Qc}=je,{RecoilRoot:el,useStoreRef:tl}=be,{useMemo:nl}=H.default;function ol(){Qc().mode;let e=tl().current;return nl(()=>{function t({children:n}){return H.default.createElement(el,{store_INTERNAL:e},n)}return t},[e])}var rl=ol,{loadableWithValue:al}=dt,{initializeNode:il}=Ee,{DEFAULT_VALUE:sl,getNode:cl}=de,{copyTreeState:ll,getRecoilValueAsLoadable:ul,invalidateDownstreams:dl,writeLoadableToTreeState:fl}=Se;function ho(e){return cl(e.key).nodeType==="atom"}var Tn=class{constructor(t,n){U(this,"_store",void 0),U(this,"_treeState",void 0),U(this,"_changes",void 0),U(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!ho(o))throw I("Reading selectors within atomicUpdate is not supported");let r=ul(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:I(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),U(this,"set",(o,r)=>{if(!ho(o))throw I("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){let a=this.get(o);this._changes.set(o.key,r(a))}else il(this._store,o.key,"set"),this._changes.set(o.key,r)}),U(this,"reset",o=>{this.set(o,sl)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;let t=ll(this._treeState);for(let[n,o]of this._changes)fl(t,n,al(o));return dl(this._store,t),t}};function hl(e){return t=>{e.replaceState(n=>{let o=new Tn(e,n);return t(o),o.newTreeState_INTERNAL()})}}var _l={atomicUpdater:hl},pl=_l.atomicUpdater,pr=Object.freeze({__proto__:null,atomicUpdater:pl});function vl(e,t){if(!e)throw new Error(t)}var Rl=vl,ot=Rl,{atomicUpdater:Sl}=pr,{batchUpdates:ml}=Gt,{DEFAULT_VALUE:yl}=de,{useStoreRef:gl}=be,{refreshRecoilValue:bl,setRecoilValue:_o}=Se,{cloneSnapshot:Tl}=Ht,{gotoSnapshot:El}=_r,{useCallback:Nl}=H.default,Dt=class{},wl=new Dt;function vr(e,t,n,o){let r=wl,a;if(ml(()=>{let l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw I(l);let u=Lo({...o??{},set:(_,v)=>_o(e,_,v),reset:_=>_o(e,_,yl),refresh:_=>bl(e,_),gotoSnapshot:_=>El(e,_),transact_UNSTABLE:_=>Sl(e)(_)},{snapshot:()=>{let _=Tl(e);return a=_.retain(),_}}),f=t(u);if(typeof f!="function")throw I(l);r=f(...n)}),r instanceof Dt&&ot(!1),K(r))r=r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var i;(i=a)===null||i===void 0||i()}return r}function Al(e,t){let n=gl();return Nl((...o)=>vr(n.current,e,o),t!=null?[...t,n]:void 0)}var Rr={recoilCallback:vr,useRecoilCallback:Al},{useStoreRef:Vl}=be,{refreshRecoilValue:Ll}=Se,{useCallback:Cl}=H.default;function $l(e){let t=Vl();return Cl(()=>{let n=t.current;Ll(n,e)},[e,t])}var Ul=$l,{atomicUpdater:Il}=pr,{useStoreRef:Dl}=be,{useMemo:Ml}=H.default;function Ol(e,t){let n=Dl();return Ml(()=>(...o)=>{Il(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var kl=Ol,En=class{constructor(t){U(this,"value",void 0),this.value=t}},Bl={WrappedValue:En},Pl=Bl.WrappedValue,Sr=Object.freeze({__proto__:null,WrappedValue:Pl}),{isFastRefreshEnabled:xl}=je,Mt=class extends Error{},Nn=class{constructor(t){var n,o,r;U(this,"_name",void 0),U(this,"_numLeafs",void 0),U(this,"_root",void 0),U(this,"_onHit",void 0),U(this,"_onSet",void 0),U(this,"_mapNodeValue",void 0),this._name=t?.name,this._numLeafs=0,this._root=null,this._onHit=(n=t?.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t?.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t?.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n?.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;let r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){let r=()=>{var a,i,l,u;let f,_;for(let[X,ne]of t){var v,C,L;let E=this._root;if(E?.type==="leaf")throw this.invalidCacheError();let B=f;if(f=B?B.branches.get(_):E,f=(v=f)!==null&&v!==void 0?v:{type:"branch",nodeKey:X,parent:B,branches:new Map,branchKey:_},f.type!=="branch"||f.nodeKey!==X)throw this.invalidCacheError();B?.branches.set(_,f),o==null||(C=o.onNodeVisit)===null||C===void 0||C.call(o,f),_=this._mapNodeValue(ne),this._root=(L=this._root)!==null&&L!==void 0?L:f}let y=f?(a=f)===null||a===void 0?void 0:a.branches.get(_):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==_))throw this.invalidCacheError();let N={type:"leaf",value:n,parent:f,branchKey:_};(i=f)===null||i===void 0||i.branches.set(_,N),this._root=(l=this._root)!==null&&l!==void 0?l:N,this._numLeafs++,this._onSet(N),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,N)};try{r()}catch(a){if(a instanceof Mt)this.clear(),r();else throw a}}delete(t){let n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){let t=xl()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw se(t+(this._name!=null?` - ${this._name}`:"")),new Mt}},Fl={TreeCache:Nn},zl=Fl.TreeCache,mr=Object.freeze({__proto__:null,TreeCache:zl}),wn=class{constructor(t){var n;U(this,"_maxSize",void 0),U(this,"_size",void 0),U(this,"_head",void 0),U(this,"_tail",void 0),U(this,"_map",void 0),U(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){let n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){let o=this._keyMapper(t);this._map.get(o)&&this.delete(t);let a=this.head(),i={key:t,right:a,left:null,value:n};a?a.left=i:this._tail=i,this._map.set(o,i),this._head=i,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){let t=this.tail();t&&this.delete(t.key)}delete(t){let n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;let o=Y(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Wl={LRUCache:wn},Gl=Wl.LRUCache,yr=Object.freeze({__proto__:null,LRUCache:Gl}),{LRUCache:Kl}=yr,{TreeCache:Hl}=mr;function ql({name:e,maxSize:t,mapNodeValue:n=o=>o}){let o=new Kl({maxSize:t}),r=new Hl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{let i=o.tail();o.set(a,!0),i&&r.size()>t&&r.delete(i.key)}});return r}var po=ql;function Re(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(t?.allowFunctions!==!0)throw I("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(K(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>Re(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return Re(e.toJSON(n),t,n);if(e instanceof Map){let r={};for(let[a,i]of e)r[typeof a=="string"?a:Re(a,t)]=i;return Re(r,t,n)}return e instanceof Set?Re(Array.from(e).sort((r,a)=>Re(r,t).localeCompare(Re(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?Re(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${Re(r,t)}:${Re(e[r],t,r)}`).join(",")}}`}function jl(e,t={allowFunctions:!1}){return Re(e,t)}var Xt=jl,{TreeCache:Zl}=mr,St={equality:"reference",eviction:"keep-all",maxSize:1/0};function Yl({equality:e=St.equality,eviction:t=St.eviction,maxSize:n=St.maxSize}=St,o){let r=Xl(e);return Jl(t,n,r,o)}function Xl(e){switch(e){case"reference":return t=>t;case"value":return t=>Xt(t)}throw I(`Unrecognized equality policy ${e}`)}function Jl(e,t,n,o){switch(e){case"keep-all":return new Zl({name:o,mapNodeValue:n});case"lru":return po({name:o,maxSize:Y(t),mapNodeValue:n});case"most-recent":return po({name:o,maxSize:1,mapNodeValue:n})}throw I(`Unrecognized eviction policy ${e}`)}var Ql=Yl;var{isReactNative:Vd,isWindow:Ld}=_t;function eu(e){return()=>null}var tu={startPerfBlock:eu},{isLoadable:nu,loadableWithError:mt,loadableWithPromise:ou,loadableWithValue:ln}=dt,{WrappedValue:gr}=Sr,{getNodeLoadable:yt,peekNodeLoadable:ru,setNodeValue:au}=Ee,{saveDepsToStore:iu}=ft,{DEFAULT_VALUE:su,getConfigDeletionHandler:cu,getNode:lu,registerNode:vo}=de,{isRecoilValue:uu}=Le,{markRecoilValueModified:Ro}=Se,{retainedByOptionWithDefault:du}=Ue,{recoilCallback:fu}=Rr,{startPerfBlock:hu}=tu,Ot=class{},et=new Ot,tt=[],gt=new Map,_u=(()=>{let e=0;return()=>e++})();function br(e){let t=null,{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,i=new Set,l=Ql(r??{equality:"reference",eviction:"keep-all"},n),u=du(e.retainedBy_UNSTABLE),f=new Map,_=0;function v(){return!G("recoil_memory_managament_2020")||_>0}function C(d){return d.getState().knownSelectors.add(n),_++,()=>{_--}}function L(){return cu(n)!==void 0&&!v()}function y(d,p,R,$,b){De(p,$,b),N(d,R)}function N(d,p){fe(d,p)&&re(d),ne(p,!0)}function X(d,p){fe(d,p)&&(Y(F(d)).stateVersions.clear(),ne(p,!1))}function ne(d,p){let R=gt.get(d);if(R!=null){for(let $ of R)Ro($,Y(t));p&&gt.delete(d)}}function E(d,p){let R=gt.get(p);R==null&&gt.set(p,R=new Set),R.add(d)}function B(d,p,R,$,b,O){return p.then(k=>{if(!v())throw re(d),et;let T=ln(k);return y(d,R,b,T,$),k}).catch(k=>{if(!v())throw re(d),et;if(K(k))return J(d,k,R,$,b,O);let T=mt(k);throw y(d,R,b,T,$),k})}function J(d,p,R,$,b,O){return p.then(k=>{if(!v())throw re(d),et;O.loadingDepKey!=null&&O.loadingDepPromise===p?R.atomValues.set(O.loadingDepKey,ln(k)):d.getState().knownSelectors.forEach(W=>{R.atomValues.delete(W)});let T=Q(d,R);if(T&&T.state!=="loading"){if((fe(d,b)||F(d)==null)&&N(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!fe(d,b)){let W=ye(d,R);if(W!=null)return W.loadingLoadable.contents}let[te,ee]=q(d,R,b);if(te.state!=="loading"&&y(d,R,b,te,ee),te.state==="hasError")throw te.contents;return te.contents}).catch(k=>{if(k instanceof Ot)throw et;if(!v())throw re(d),et;let T=mt(k);throw y(d,R,b,T,$),k})}function z(d,p,R,$){var b,O,k,T;if(fe(d,$)||p.version===((b=d.getState())===null||b===void 0||(O=b.currentTree)===null||O===void 0?void 0:O.version)||p.version===((k=d.getState())===null||k===void 0||(T=k.nextTree)===null||T===void 0?void 0:T.version)){var te,ee,W;iu(n,R,d,(te=(ee=d.getState())===null||ee===void 0||(W=ee.nextTree)===null||W===void 0?void 0:W.version)!==null&&te!==void 0?te:d.getState().currentTree.version)}for(let j of R)i.add(j)}function q(d,p,R){let $=hu(n),b=!0,O=!0,k=()=>{$(),O=!1},T,te=!1,ee,W={loadingDepKey:null,loadingDepPromise:null},j=new Map;function he({key:ie}){let _e=yt(d,p,ie);switch(j.set(ie,_e),b||(z(d,p,new Set(j.keys()),R),X(d,R)),_e.state){case"hasValue":return _e.contents;case"hasError":throw _e.contents;case"loading":throw W.loadingDepKey=ie,W.loadingDepPromise=_e.contents,_e.contents}throw I("Invalid Loadable state")}let ke=ie=>(..._e)=>{if(O)throw I("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&ot(!1),fu(d,ie,_e,{node:t})};try{T=o({get:he,getCallback:ke}),T=uu(T)?he(T):T,nu(T)&&(T.state==="hasError"&&(te=!0),T=T.contents),K(T)?T=B(d,T,p,j,R,W).finally(k):k(),T=T instanceof gr?T.value:T}catch(ie){T=ie,K(T)?T=J(d,T,p,j,R,W).finally(k):(te=!0,k())}return te?ee=mt(T):K(T)?ee=ou(T):ee=ln(T),b=!1,we(d,R,j),z(d,p,new Set(j.keys()),R),[ee,j]}function Q(d,p){let R=p.atomValues.get(n);if(R!=null)return R;let $=new Set;try{R=l.get(O=>(typeof O!="string"&&ot(!1),yt(d,p,O).contents),{onNodeVisit:O=>{O.type==="branch"&&O.nodeKey!==n&&$.add(O.nodeKey)}})}catch(O){throw I(`Problem with cache lookup for selector "${n}": ${O.message}`)}if(R){var b;p.atomValues.set(n,R),z(d,p,$,(b=F(d))===null||b===void 0?void 0:b.executionID)}return R}function ce(d,p){let R=Q(d,p);if(R!=null)return re(d),R;let $=ye(d,p);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&E(d,$.executionID),$.loadingLoadable}let O=_u(),[k,T]=q(d,p,O);return k.state==="loading"?(ae(d,O,k,T,p),E(d,O)):(re(d),De(p,k,T)),k}function ye(d,p){let R=Ho([f.has(d)?[Y(f.get(d))]:[],xt(In(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(let[O,k]of b)if(!yt(d,p,O).is(k))return!0;return!1}for(let b of R){if(b.stateVersions.get(p.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(p.version,!0),b;b.stateVersions.set(p.version,!1)}}function F(d){return f.get(d)}function ae(d,p,R,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:p,loadingLoadable:R,stateVersions:new Map([[b.version,!0]])})}function we(d,p,R){if(fe(d,p)){let $=F(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=R)}}function re(d){f.delete(d)}function fe(d,p){var R;return p===((R=F(d))===null||R===void 0?void 0:R.executionID)}function Ie(d){return Array.from(d.entries()).map(([p,R])=>[p,R.contents])}function De(d,p,R){d.atomValues.set(n,p);try{l.set(Ie(R),p)}catch($){throw I(`Problem with setting cache for selector "${n}": ${$.message}`)}}function ge(d){if(tt.includes(n)){let p=`Recoil selector has circular dependencies: ${tt.slice(tt.indexOf(n)).join(" \u2192 ")}`;return mt(I(p))}tt.push(n);try{return d()}finally{tt.pop()}}function Me(d,p){let R=p.atomValues.get(n);return R??l.get($=>{var b;return typeof $!="string"&&ot(!1),(b=ru(d,p,$))===null||b===void 0?void 0:b.contents})}function Oe(d,p){return ge(()=>ce(d,p))}function P(d){d.atomValues.delete(n)}function x(d,p){t==null&&ot(!1);for(let $ of i){var R;let b=lu($);(R=b.clearCache)===null||R===void 0||R.call(b,d,p)}i.clear(),P(p),l.clear(),Ro(d,t)}return a!=null?t=vo({key:n,nodeType:"selector",peek:Me,get:Oe,set:(p,R,$)=>{let b=!1,O=new Map;function k({key:W}){if(b)throw I("Recoil: Async selector sets are not currently supported.");let j=yt(p,R,W);if(j.state==="hasValue")return j.contents;if(j.state==="loading"){let he=`Getting value of asynchronous atom or selector "${W}" in a pending state while setting selector "${n}" is not yet supported.`;throw se(he),I(he)}else throw j.contents}function T(W,j){if(b){let ie="Recoil: Async selector sets are not currently supported.";throw se(ie),I(ie)}let he=typeof j=="function"?j(k(W)):j;au(p,R,W.key,he).forEach((ie,_e)=>O.set(_e,ie))}function te(W){T(W,su)}let ee=a({set:T,get:k,reset:te},$);if(ee!==void 0)throw K(ee)?I("Recoil: Async selector sets are not currently supported."):I("Recoil: selector set should be a void function.");return b=!0,O},init:C,invalidate:P,clearCache:x,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=vo({key:n,nodeType:"selector",peek:Me,get:Oe,init:C,invalidate:P,clearCache:x,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}br.value=e=>new gr(e);var He=br,{isLoadable:pu,loadableWithError:un,loadableWithPromise:dn,loadableWithValue:Pe}=dt,{WrappedValue:Tr}=Sr,{peekNodeInfo:vu}=Ee,{DEFAULT_VALUE:Ae,DefaultValue:Te,getConfigDeletionHandler:Er,registerNode:Ru,setConfigDeletionHandler:Su}=de,{isRecoilValue:mu}=Le,{getRecoilValueAsLoadable:yu,markRecoilValueModified:gu,setRecoilValue:So,setRecoilValueLoadable:bu}=Se,{retainedByOptionWithDefault:Tu}=Ue,nt=e=>e instanceof Tr?e.value:e;function Eu(e){let{key:t,persistence_UNSTABLE:n}=e,o=Tu(e.retainedBy_UNSTABLE),r=0;function a(E){return dn(E.then(B=>(i=Pe(B),B)).catch(B=>{throw i=un(B),B}))}let i=K(e.default)?a(e.default):pu(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:Pe(nt(e.default));i.contents;let l,u=new Map;function f(E){return E}function _(E,B){let J=B.then(z=>{var q,Q;return((Q=((q=E.getState().nextTree)!==null&&q!==void 0?q:E.getState().currentTree).atomValues.get(t))===null||Q===void 0?void 0:Q.contents)===J&&So(E,ne,z),z}).catch(z=>{var q,Q;throw((Q=((q=E.getState().nextTree)!==null&&q!==void 0?q:E.getState().currentTree).atomValues.get(t))===null||Q===void 0?void 0:Q.contents)===J&&bu(E,ne,un(z)),z});return J}function v(E,B,J){var z;r++;let q=()=>{var F;r--,(F=u.get(E))===null||F===void 0||F.forEach(ae=>ae()),u.delete(E)};if(E.getState().knownAtoms.add(t),i.state==="loading"){let F=()=>{var ae;((ae=E.getState().nextTree)!==null&&ae!==void 0?ae:E.getState().currentTree).atomValues.has(t)||gu(E,ne)};i.contents.finally(F)}let Q=(z=e.effects)!==null&&z!==void 0?z:e.effects_UNSTABLE;if(Q!=null){let fe=function(P){if(ae&&P.key===t){let x=F;return x instanceof Te?C(E,B):K(x)?dn(x.then(d=>d instanceof Te?i.toPromise():d)):Pe(x)}return yu(E,P)},Ie=function(P){return fe(P).toPromise()},De=function(P){var x;let d=vu(E,(x=E.getState().nextTree)!==null&&x!==void 0?x:E.getState().currentTree,P.key);return ae&&P.key===t&&!(F instanceof Te)?{...d,isSet:!0,loadable:fe(P)}:d},F=Ae,ae=!0,we=!1,re=null,ge=P=>x=>{if(ae){let d=fe(ne),p=d.state==="hasValue"?d.contents:Ae;F=typeof x=="function"?x(p):x,K(F)&&(F=F.then(R=>(re={effect:P,value:R},R)))}else{if(K(x))throw I("Setting atoms to async values is not implemented.");typeof x!="function"&&(re={effect:P,value:nt(x)}),So(E,ne,typeof x=="function"?d=>{let p=nt(x(d));return re={effect:P,value:p},p}:nt(x))}},Me=P=>()=>ge(P)(Ae),Oe=P=>x=>{var d;let{release:p}=E.subscribeToTransactions(R=>{var $;let{currentTree:b,previousTree:O}=R.getState();O||(se("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),O=b);let k=($=b.atomValues.get(t))!==null&&$!==void 0?$:i;if(k.state==="hasValue"){var T,te,ee,W;let j=k.contents,he=(T=O.atomValues.get(t))!==null&&T!==void 0?T:i,ke=he.state==="hasValue"?he.contents:Ae;((te=re)===null||te===void 0?void 0:te.effect)!==P||((ee=re)===null||ee===void 0?void 0:ee.value)!==j?x(j,ke,!b.atomValues.has(t)):((W=re)===null||W===void 0?void 0:W.effect)===P&&(re=null)}},t);u.set(E,[...(d=u.get(E))!==null&&d!==void 0?d:[],p])};for(let P of Q)try{let x=P({node:ne,storeID:E.storeID,parentStoreID_UNSTABLE:E.parentStoreID,trigger:J,setSelf:ge(P),resetSelf:Me(P),onSet:Oe(P),getPromise:Ie,getLoadable:fe,getInfo_UNSTABLE:De});if(x!=null){var ce;u.set(E,[...(ce=u.get(E))!==null&&ce!==void 0?ce:[],x])}}catch(x){F=x,we=!0}if(ae=!1,!(F instanceof Te)){var ye;let P=we?un(F):K(F)?dn(_(E,F)):Pe(nt(F));P.contents,B.atomValues.set(t,P),(ye=E.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,P)}}return q}function C(E,B){var J,z;return(J=(z=B.atomValues.get(t))!==null&&z!==void 0?z:l)!==null&&J!==void 0?J:i}function L(E,B){if(B.atomValues.has(t))return Y(B.atomValues.get(t));if(B.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return Cn(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),i;let J=B.nonvalidatedAtoms.get(t),z=n.validator(J,Ae);return l=z instanceof Te?i:Pe(z),l}else return i}function y(){l=void 0}function N(E,B,J){if(B.atomValues.has(t)){let z=Y(B.atomValues.get(t));if(z.state==="hasValue"&&J===z.contents)return new Map}else if(!B.nonvalidatedAtoms.has(t)&&J instanceof Te)return new Map;return l=void 0,new Map().set(t,Pe(J))}function X(){return Er(t)!==void 0&&r<=0}let ne=Ru({key:t,nodeType:"atom",peek:C,get:L,set:N,init:v,invalidate:y,shouldDeleteConfigOnRelease:X,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return ne}function Wn(e){let{...t}=e,n="default"in e?e.default:new Promise(()=>{});return mu(n)?Nu({...t,default:n}):Eu({...t,default:n})}function Nu(e){let t=Wn({...e,default:Ae,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Te?o:Y(e.persistence_UNSTABLE).validator(o,Ae)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=He({key:`${e.key}__withFallback`,get:({get:o})=>{let r=o(t);return r instanceof Te?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Su(n.key,Er(e.key)),n}Wn.value=e=>new Tr(e);var Nr=Wn,An=class{constructor(t){var n;U(this,"_map",void 0),U(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t?.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}},wu={MapCache:An},Au=wu.MapCache,Vu=Object.freeze({__proto__:null,MapCache:Au}),{LRUCache:mo}=yr,{MapCache:Lu}=Vu,bt={equality:"reference",eviction:"none",maxSize:1/0};function Cu({equality:e=bt.equality,eviction:t=bt.eviction,maxSize:n=bt.maxSize}=bt){let o=$u(e);return Uu(t,n,o)}function $u(e){switch(e){case"reference":return t=>t;case"value":return t=>Xt(t)}throw I(`Unrecognized equality policy ${e}`)}function Uu(e,t,n){switch(e){case"keep-all":return new Lu({mapKey:n});case"lru":return new mo({mapKey:n,maxSize:Y(t)});case"most-recent":return new mo({mapKey:n,maxSize:1})}throw I(`Unrecognized eviction policy ${e}`)}var wr=Cu,{setConfigDeletionHandler:Iu}=de;function Du(e){var t,n;let o=wr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,i;let l=o.get(r);if(l!=null)return l;let{cachePolicyForParams_UNSTABLE:u,...f}=e,_="default"in e?e.default:new Promise(()=>{}),v=Nr({...f,key:`${e.key}__${(a=Xt(r))!==null&&a!==void 0?a:"void"}`,default:typeof _=="function"?_(r):_,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(i=e.effects)!==null&&i!==void 0?i:e.effects_UNSTABLE});return o.set(r,v),Iu(v.key,()=>{o.delete(r)}),v}}var Mu=Du,{setConfigDeletionHandler:Ou}=de,ku=0;function Bu(e){var t,n;let o=wr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let i;try{i=o.get(r)}catch(C){throw I(`Problem with cache lookup for selector ${e.key}: ${C.message}`)}if(i!=null)return i;let l=`${e.key}__selectorFamily/${(a=Xt(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${ku++}`,u=C=>e.get(r)(C),f=e.cachePolicy_UNSTABLE,_=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,v;if(e.set!=null){let C=e.set;v=He({key:l,get:u,set:(y,N)=>C(r)(y,N),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:_})}else v=He({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:_});return o.set(r,v),Ou(v.key,()=>{o.delete(r)}),v}}var Ne=Bu,Pu=Ne({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function xu(e){return Pu(e)}var Fu=xu,zu=Ne({key:"__error",get:e=>()=>{throw I(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Wu(e){return zu(e)}var Gu=Wu;function Ku(e){return e}var Hu=Ku,{loadableWithError:Ar,loadableWithPromise:Vr,loadableWithValue:Lr}=dt;function Jt(e,t){let n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(let[r,a]of t.entries())try{n[r]=e(a)}catch(i){o[r]=i}return[n,o]}function qu(e){return e!=null&&!K(e)}function Qt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function Vn(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function xe(e,t,n){let o=n.map((r,a)=>r==null?Lr(t[a]):K(r)?Vr(r):Ar(r));return Vn(e,o)}function ju(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}var Zu=Ne({key:"__waitForNone",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);return xe(e,o,r)},dangerouslyAllowMutability:!0}),Yu=Ne({key:"__waitForAny",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);return r.some(a=>!K(a))?xe(e,o,r):new Promise(a=>{for(let[i,l]of r.entries())K(l)&&l.then(u=>{o[i]=u,r[i]=void 0,a(xe(e,o,r))}).catch(u=>{r[i]=u,a(xe(e,o,r))})})},dangerouslyAllowMutability:!0}),Xu=Ne({key:"__waitForAll",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);if(r.every(i=>i==null))return Vn(e,o);let a=r.find(qu);if(a!=null)throw a;return Promise.all(r).then(i=>Vn(e,ju(o,i)))},dangerouslyAllowMutability:!0}),Ju=Ne({key:"__waitForAllSettled",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);return r.every(a=>!K(a))?xe(e,o,r):Promise.all(r.map((a,i)=>K(a)?a.then(l=>{o[i]=l,r[i]=void 0}).catch(l=>{o[i]=void 0,r[i]=l}):null)).then(()=>xe(e,o,r))},dangerouslyAllowMutability:!0}),Qu=Ne({key:"__noWait",get:e=>({get:t})=>{try{return He.value(Lr(t(e)))}catch(n){return He.value(K(n)?Vr(n):Ar(n))}},dangerouslyAllowMutability:!0}),ed={waitForNone:Zu,waitForAny:Yu,waitForAll:Xu,waitForAllSettled:Ju,noWait:Qu},{RecoilLoadable:td}=dt,{DefaultValue:nd}=de,{RecoilRoot:od,useRecoilStoreID:rd}=be,{isRecoilValue:ad}=Le,{retentionZone:id}=zt,{freshSnapshot:sd}=Ht,{useRecoilState:cd,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ld,useRecoilStateLoadable:ud,useRecoilValue:dd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:fd,useRecoilValueLoadable:hd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:_d,useResetRecoilState:pd,useSetRecoilState:vd}=$c,{useGotoRecoilSnapshot:Rd,useRecoilSnapshot:Sd,useRecoilTransactionObserver:md}=_r,{useRecoilCallback:yd}=Rr,{noWait:gd,waitForAll:bd,waitForAllSettled:Td,waitForAny:Ed,waitForNone:Nd}=ed,M={DefaultValue:nd,isRecoilValue:ad,RecoilLoadable:td,RecoilEnv:qe,RecoilRoot:od,useRecoilStoreID:rd,useRecoilBridgeAcrossReactRoots_UNSTABLE:rl,atom:Nr,selector:He,atomFamily:Mu,selectorFamily:Ne,constSelector:Fu,errorSelector:Gu,readOnlySelector:Hu,noWait:gd,waitForNone:Nd,waitForAny:Ed,waitForAll:bd,waitForAllSettled:Td,useRecoilValue:dd,useRecoilValueLoadable:hd,useRecoilState:cd,useRecoilStateLoadable:ud,useSetRecoilState:vd,useResetRecoilState:pd,useGetRecoilValueInfo_UNSTABLE:Jc,useRecoilRefresher_UNSTABLE:Ul,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:_d,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:fd,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ld,useRecoilCallback:yd,useRecoilTransaction_UNSTABLE:kl,useGotoRecoilSnapshot:Rd,useRecoilSnapshot:Sd,useRecoilTransactionObserver_UNSTABLE:md,snapshot_UNSTABLE:sd,useRetain:Bn,retentionZone:id},Cd=M.DefaultValue,$d=M.isRecoilValue,Ud=M.RecoilLoadable,Id=M.RecoilEnv,Dd=M.RecoilRoot,Md=M.useRecoilStoreID,Od=M.useRecoilBridgeAcrossReactRoots_UNSTABLE,Cr=M.atom,kd=M.selector,Bd=M.atomFamily,Pd=M.selectorFamily,xd=M.constSelector,Fd=M.errorSelector,zd=M.readOnlySelector,Wd=M.noWait,Gd=M.waitForNone,Kd=M.waitForAny,Hd=M.waitForAll,qd=M.waitForAllSettled,jd=M.useRecoilValue,Zd=M.useRecoilValueLoadable,Yd=M.useRecoilState,Xd=M.useRecoilStateLoadable,Jd=M.useSetRecoilState,Qd=M.useResetRecoilState,ef=M.useGetRecoilValueInfo_UNSTABLE,tf=M.useRecoilRefresher_UNSTABLE,nf=M.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,of=M.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,rf=M.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,af=M.useRecoilCallback,sf=M.useRecoilTransaction_UNSTABLE,cf=M.useGotoRecoilSnapshot,lf=M.useRecoilSnapshot,uf=M.useRecoilTransactionObserver_UNSTABLE,df=M.snapshot_UNSTABLE,ff=M.useRetain,hf=M.retentionZone;var Sf=Cr({key:"UserConfigState",default:Yn});export{Dd as a,Cr as b,jd as c,Yd as d,Jd as e,Qd as f,Sf as g};
